<!DOCTYPE html>
<!--
powered by:
         __    __  ________          ________
        / /   / / / ______/ ______  / ____  /
       / /   / / /_/   __  /     / / /___/_/
      /_/___/ / ______/ / / ____/ / ____/_  _______
       /_____/ /_______/ /_/     /_/   /_/ /______/
-->
<html>
<head>
    <title>SOlarSystem</title>
    <link rel="stylesheet" href="css/reset.css"/>
    <link rel="stylesheet" href="css/style.css"/>
    <script src="js/Stats.js"></script>
    <script src="js/bower_components/socket.io-client/dist/socket.io.js"></script>
    <script type="text/javascript" src="js/lib/Box2dWeb-2.1.a.3.min.js"></script>
    <script type="text/javascript">

        /**
         * Keycode constants
         */
        var KEY = {
                SHIFT: 16, CTRL: 17, ESC: 27, RIGHT: 39, UP: 38, LEFT: 37, DOWN: 40, SPACE: 32,
                A: 65, D: 68, E: 69, G: 71, L: 76,Q: 81, P: 80, R: 82, S: 83, T: 84, W: 87, Z: 90, OPENBRACKET: 219, CLOSEBRACKET: 221
            };
        /**
         * Size screen
         */
        var minimum_screen_size = {x:640, y:480};

        /**
         * Id dom element
         */
        var dom_obj_id = "canvas";

        /**
         * Ideal FPS constant
         */
        var FPSMS = 1000 / 60;

        /**
         * onload page
         */
        document.addEventListener('DOMContentLoaded',function(){

            // connection to the server via socked
            var socket = io.connect('',{'reconnect': false});
            socket
                    .on('message', function (message) {
                        console.log(message);
                        //socket.emit('my other event', { my: 'data' });
                    })
                    .on('connect', function(){
                        console.log('connect');
                    })
                    .on('disconnect', function(){
                        console.log('disconnect');
                        setTimeout(reconnect,500)
                    });
            function reconnect(){
                socket.once('error', function(){
                    setTimeout(reconnect, 500);
                });
                socket.socket.connect();

            }

            if(typeof Stats != 'undefined'){
                var stats = new Stats();
                stats.setMode(0);
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.left = '0px';
                stats.domElement.style.top = '0px';

                document.body.appendChild( stats.domElement );
                stats.begin();
            }
            init();
            if(typeof Stats != 'undefined'){
                stats.end();
            }
        });

        /**
         * On resize
         */
        window.onresize = function(event) {
            set_fullscreen();
        }

        /**
         * Resize the dom element
         */
        function set_fullscreen(){
            var dom_obj = document.getElementById(dom_obj_id);
            if (minimum_screen_size.x <= dom_obj.offsetWidth || minimum_screen_size.y <= dom_obj.offsetHeight) {
                var w = window,
                    d = document,
                    e = d.documentElement,
                    g = d.getElementsByTagName('body')[0],
                    x = w.innerWidth || e.clientWidth || g.clientWidth,
                    y = w.innerHeight || e.clientHeight || g.clientHeight;

                if(dom_obj.offsetWidth != x){
                    dom_obj.style.width = x+"px";
                }
                if(dom_obj.offsetHeight != y){
                    dom_obj.style.height = y+"px";
                }
            }
        }

        /**
         * Initialization of applicaion
         */
        function init() {
            set_fullscreen();
            var b2Vec2 = Box2D.Common.Math.b2Vec2;
            var b2AABB = Box2D.Collision.b2AABB;
            var b2BodyDef = Box2D.Dynamics.b2BodyDef;
            var b2Body = Box2D.Dynamics.b2Body;
            var b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
            var b2Fixture = Box2D.Dynamics.b2Fixture;
            var b2World = Box2D.Dynamics.b2World;
            var b2MassData = Box2D.Collision.Shapes.b2MassData;
            var b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
            var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
            var b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
            var b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef;

            var world = new b2World(
                    new b2Vec2(0, 0.1)    //gravity
                    , true               //allow sleep
            );
            //set the gravity
            world.SetGravity(new b2Vec2(0, 9.8));

            var fixDef = new b2FixtureDef;
            fixDef.density = 1.0;
            fixDef.friction = 0.5;
            fixDef.restitution = 0.2;

            var bodyDef = new b2BodyDef;

            //create ground
            bodyDef.type = b2Body.b2_staticBody;
            fixDef.shape = new b2PolygonShape;
            fixDef.shape.SetAsBox(2, 2);
            bodyDef.position.Set(10, 450 / 30 + 1.8);
            world.CreateBody(bodyDef).CreateFixture(fixDef);
            /*bodyDef.position.Set(10, -1.8);
            world.CreateBody(bodyDef).CreateFixture(fixDef);
            fixDef.shape.SetAsBox(2, 14);
            bodyDef.position.Set(-1.8, 13);
            world.CreateBody(bodyDef).CreateFixture(fixDef);
            bodyDef.position.Set(21.8, 13);
            world.CreateBody(bodyDef).CreateFixture(fixDef);*/

            //create some objects
            bodyDef.type = b2Body.b2_dynamicBody;
            for (var i = 0; i < 1; ++i) {
                if (Math.random() > 0.5) {
                    fixDef.shape = new b2PolygonShape;
                    fixDef.shape.SetAsBox(
                            Math.random() + 0.1 //half width
                            , Math.random() + 0.1 //half height
                    );
                } else {
                    fixDef.shape = new b2CircleShape(
                            Math.random() + 0.1 //radius
                    );
                }
                bodyDef.position.x = Math.random() * 10;
                bodyDef.position.y = Math.random() * 10;
                world.CreateBody(bodyDef).CreateFixture(fixDef);
            }

            var ship = addCircle(4,4,0.5);

            var dom_obj = document.getElementById(dom_obj_id);
            //setup debug draw
            var debugDraw = new b2DebugDraw();
            debugDraw.SetSprite(dom_obj.getContext("2d"));
            debugDraw.SetDrawScale(30.0);
            debugDraw.SetFillAlpha(0.5);
            debugDraw.SetLineThickness(1.0);
            debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
            world.SetDebugDraw(debugDraw);

            window.setInterval(update, FPSMS);

            //mouse

            var mouseX, mouseY, mousePVec, isMouseDown, selectedBody, mouseJoint;
            var canvasPosition = getElementPosition(dom_obj);

            document.addEventListener("mousedown", function (e) {
                isMouseDown = true;
                handleMouseMove(e);
                document.addEventListener("mousemove", handleMouseMove, true);
            }, true);

            document.addEventListener("mouseup", function () {
                document.removeEventListener("mousemove", handleMouseMove, true);
                isMouseDown = false;
                mouseX = undefined;
                mouseY = undefined;
            }, true);

            //pressed
            document.addEventListener('keydown', function(e){
                switch(e.keyCode)
                {
                    case KEY.W: move_forward(); break; // w
                    case KEY.A: turn_left(); break; // a
                    case KEY.S: move_back(); break; // s
                    case KEY.D: turn_right(); break; // d
                    case KEY.Q: strafe_left(); break; // q
                    case KEY.E: strafe_right(); break; // e
                }
            });
            //released
            window.onkeyup = function(e){

            }

            function move_forward(){
                console.log('top');
                move(ship, 0.0, -0.50);
            }
            function turn_left(){
                angle = ship.GetBody().GetAngle();
                ship.GetBody().SetAngle(angle - 0.1);
            }
            function move_back(){
                console.log('back');
                move(ship, 0.0, 50.0);
            }
            function turn_right(){
                angle = ship.GetBody().GetAngle();
                ship.GetBody().SetAngle(angle + 0.1);
            }
            function strafe_left(){
                move(ship, -.50, 0.0);
            }
            function strafe_right(){
                move(ship, 0.50, 0.0);
            }

            function move(obj, x, y) {
                /*
                 var f = m_body.getWorldVector(new b2Vec2(0.0, -30.0));
                 var p = m_body.getWorldPoint(m_body.getLocalCenter().add(new Vec2(0.0, 2.0)));
                 m_body.applyForce(f, p);*/

                var b2Vec2 = Box2D.Common.Math.b2Vec2;
                var body = obj.GetBody();
                var method = (y>0) ? 'ApplyForce' : 'ApplyImpulse';

                body[method](new b2Vec2(x, y), body.GetWorldCenter());
            }

            function keyPressed_handler(e) {
                console.log(e);
                if(e.keyCode == Keyboard.UP){
                    body.WakeUp();
                    engineSpeed = -HORSEPOWERS;
                }
                if(e.keyCode == Keyboard.DOWN){
                    engineSpeed = HORSEPOWERS;
                }
                if(e.keyCode == Keyboard.RIGHT){
                    steeringAngle = MAX_STEER_ANGLE
                }
                if(e.keyCode == Keyboard.LEFT){
                    steeringAngle = -MAX_STEER_ANGLE
                }
            }

            function keyReleased_handler(e){
                if(e.keyCode == Keyboard.UP || e.keyCode == Keyboard.DOWN){
                    engineSpeed = 0;
                }
                if(e.keyCode == Keyboard.LEFT || e.keyCode == Keyboard.RIGHT){
                    steeringAngle = 0;
                }
            }

            function handleMouseMove(e) {
                mouseX = (e.clientX - canvasPosition.x) / 30;
                mouseY = (e.clientY - canvasPosition.y) / 30;
            }

            function getBodyAtMouse() {
                mousePVec = new b2Vec2(mouseX, mouseY);
                var aabb = new b2AABB();
                aabb.lowerBound.Set(mouseX - 0.001, mouseY - 0.001);
                aabb.upperBound.Set(mouseX + 0.001, mouseY + 0.001);

                // Query the world for overlapping shapes.

                selectedBody = null;
                world.QueryAABB(getBodyCB, aabb);
                return selectedBody;
            }

            function getBodyCB(fixture) {
                if (fixture.GetBody().GetType() != b2Body.b2_staticBody) {
                    if (fixture.GetShape().TestPoint(fixture.GetBody().GetTransform(), mousePVec)) {
                        selectedBody = fixture.GetBody();
                        return false;
                    }
                }
                return true;
            }

            //update

            function update() {

                if (isMouseDown && (!mouseJoint)) {
                    var body = getBodyAtMouse();
                    if (body) {
                        var md = new b2MouseJointDef();
                        md.bodyA = world.GetGroundBody();
                        md.bodyB = body;
                        md.target.Set(mouseX, mouseY);
                        md.collideConnected = true;
                        md.maxForce = 200.0 * body.GetMass();
                        mouseJoint = world.CreateJoint(md);
                        body.SetAwake(true);
                    }
                }

                if (mouseJoint) {
                    if (isMouseDown) {
                        mouseJoint.SetTarget(new b2Vec2(mouseX, mouseY));
                    } else {
                        world.DestroyJoint(mouseJoint);
                        mouseJoint = null;
                    }
                }
                //options: frame-rate, velocity iterations, position iterations
                world.Step(1 / 60, 10, 10);
                world.DrawDebugData();
                world.ClearForces();
            };

            //helpers

            //http://js-tut.aardon.de/js-tut/tutorial/position.html
            function getElementPosition(element) {
                var elem = element, tagname = "", x = 0, y = 0;

                while ((typeof(elem) == "object") && (typeof(elem.tagName) != "undefined")) {
                    y += elem.offsetTop;
                    x += elem.offsetLeft;
                    tagname = elem.tagName.toUpperCase();

                    if (tagname == "BODY")
                        elem = 0;

                    if (typeof(elem) == "object") {
                        if (typeof(elem.offsetParent) == "object")
                            elem = elem.offsetParent;
                    }
                }
                return {x: x, y: y};
            }

            function addCircle(x, y, r) {
                fixDef.shape = new b2CircleShape( r );
                bodyDef.position.x = x;
                bodyDef.position.y = y;
                var dynamicBody = world.CreateBody(bodyDef).CreateFixture(fixDef);
                return dynamicBody;
                /*
                var fixDef = new b2FixtureDef;
                fixDef.density = 1.0;
                fixDef.friction = 0.5;
                fixDef.restitution = 0.2;

                var bodyDef = new b2BodyDef;
                bodyDef.type = b2Body.b2_dynamicBody;
                bodyDef.position.x = x;
                bodyDef.position.y = y;

                fixDef.shape = new b2CircleShape(r);
                world.CreateBody(bodyDef).CreateFixture(fixDef);
                */
            }
        }
    </script>
</head>
<body>
<canvas id="canvas" width="640" height="480"></canvas>
</body>
</html>